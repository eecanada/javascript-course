<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Asynchronous JavaScript</title>
  </head>
  <body>
    <h1>Asynchronous JavaScript</h1>
    <script>
      //////////////////////////////////////////////////////////////ASYNCHORNOUS JS///////////////////////////////////////////////////////////

          const second = () => {
              setTimeout(()=> {
                  console.log('Async hey there')
              }, 2000)
          }
        const first = () => {
          console.log('Hey there')
          second()
          console.log('The End')
        }
        first()

      //////////////////////////////////////////////////////CALLBACK HELL///////////////////////////////////////////////////////////////////

        function getRecipe() {
          setTimeout(() => {
            const RecipeID = [523, 883, 432, 974]
            console.log(RecipeID)

            setTimeout(
              id => {
                const recipe = {
                  title: 'Fresh Tomato Pasta',
                  publisher: 'Eder'
                }
                console.log(`${id}: ${recipe.title}`)

                setTimeout(
                  publisher => {
                    const recipe = {
                      title: 'Italian Pizze',
                      publisher: publisher
                    }
                    console.log(recipe)
                  },
                  1500,
                  recipe.publisher
                )
              },
              1000,
              RecipeID[2] // I can pass another arguement here, RecipeID[2] because I am passing it into the callback function setTimeOut(id)
            )
          }, 1500)
        }
        getRecipe()

      //////////////////////////////////////////////////////////////PROMISE///////////////////////////////////////////////////////////////

      // a promise is an object that keeop track about whethere a certain event has happened or not. and it determines what happens after the event has happened. Before the event has happened the promise is pending, then after the event has happened the promise is settled/resolved, if the promise is successful then the promise is considered fulfilled, but if there was an error the promise is rejected

       // we can either produce or consume a promise. When you produce a promise, you create a promise and send a result using that promise. We you consume it , we can use callback function for fulfillment and for rejection of the promise.





      // resolve and reject are callback functions 
      const getIDs = new Promise((resolve,reject) => {
          setTimeout(() => { //after the timer finish, the promise is successful so it will return the resolve
              resolve([523, 883, 432, 974]) //resolve takes in an arguement, which is the result of the promise. This is how I return the result from the promise if it was successful. I want to return the data in () //AKA IDS
          }, 1500)
      })

      const getRecipe = recID => { // recID is passed into the function, the name could be anything //1.
          return new Promise((resolve, reject)=>{
              setTimeout((ID)=>{ //ID === getRecipe(IDs[2]) === 432 //3. ID === recID with different name but could also be called recID
                  const recipe = {
                      title: 'Fresh Tomato Pasta',
                      publisher: 'Eder'
                  }
                  resolve(`${ID}:${recipe.title}`) // AKA Recipe // resolve is what is going to be result when the promise is fufilled
              }, 1500, recID) // this recID is passed into the setTimeout function, which will then become ID //2.
          })
      }

      const getRelated = publisher => { // publisher can be any name == getRelated('Eder') 
          return new Promise((resolve,reject)=>{
              setTimeout((pub)=>{ // == Eder' == getRelated('Eder')  === publisher
                  const recipe = {
                      title: 'Pizza',
                      publisher: 'Eder'
                  }
                  resolve(`${pub} ${recipe.title}`) 
              }, 1500, publisher)
          })
      }

       // then and catch are two methods I can use on all promise objects to consume a promise. Success = .then, rejection = .catch
      getIDs.then(IDs => { // .then takes a callback function if the promise is fufilled. The parameter IDs is the result of whatever is in resolve()
          console.log(IDs) // [523, 883, 432, 974]
          return getRecipe(IDs[2]) // this will return a promise, which is ID , IDs can be any name too === recID
      })
      .then(recipe => { // recipe will be the results of the succesfull promise getRecipe, can be named any variable name
          console.log(recipe) // 432:Fresh Tomato Pasta
          return getRelated('Eder')  // this is pub --> this is the value that is going to go into my getRelated parameter 
      })
      .then(publisher =>{ // this is the result of the promise
          console.log(publisher) // this is resolve()
      })
      .catch(error => {
          console.log(error)
      })

      //////////////////////////////////////////////////////////////ASYNC & AWAIT/////////////////////////////////////////////////////////////

      // all these are example of producing promises
          const getIDs = new Promise((resolve,reject)=>{
              setTimeout(()=> {
                  resolve([523, 883, 432, 974]) // this is going to get returned if the promise is successful
              }, 1500)
          })

          const getRecipe = recID => {
              return new Promise((resolve,reject)=>{
                  setTimeout((ID)=>{
                      const recipe = {
                          title: 'Fresh Tomato Pasta',
                          publisher: 'Eder'
                      }
                      resolve(`${ID}: ${recipe.title}`)
                  }, 1500, recID)
              })
          }

          const getRelated = publisher => {
              return new Promise((resolve,reject)=>{
                  setTimeout((pub)=>{
                      const recipe = {
                          title: 'Pizza',
                          publisher: 'Eder'
                      }
                      resolve(`${pub} ${recipe.title}`)
                  }, 1500, publisher)
              })
          }

          async function getRecipesAW() {
              const IDs = await getIDs
              console.log(IDs)
              const recipe = await getRecipe(IDs[2])
              console.log(recipe)
              const publisher =  await getRelated('Eder')
              console.log(publisher)

              // How to return result from async with .then()
              return recipe // AKA   resolve(`${ID}: ${recipe.title}`)
          }
          // the argument result of the .then callback function is the resolved value of recipe, result can be anyname
          // I am using .then to consume the getRecipesAW promise
           getRecipesAW().then(result => {
               console.log(`${result} this is working`)
           })

      //////////////////////////////////////////////////////////////FETCH/////////////////////////////////////////////////////////////

      function getWeather(woeid) {
        fetch(`https://cors-anywhere.herokuapp.com/https://www.metaweather.com/api/location/${woeid}/`) //fetch gets a data and return a promise
          .then(result => { // result is the data that came back from the fetch promise, it could have been named anything
            console.log(result) // result is json right now
            return result.json() // .json turns json to javascript, this json method returns a promise to, so I have to consume it
          })
          .then(data => {// this is consuming result.json and now I am calling that js object, data
            console.log(data)
            const today = data.consolidated_weather[0]
            console.log(
              `Temperatures in ${data.title} stay between ${today.min_temp} and ${today.max_temp} celsius`
            )
          })

          .catch(error => {
            // just used to see if there was an error
            console.log(error)
          })
      }
      getWeather(2487956) // Temperatures in San Francisco stay between 8.995000000000001 and 18.494999999999997 celsius
      getWeather(44418)

 //////////////////////////////////////////////////////////////ASYNC & AWAIT FETCH /////////////////////////////////////////////////////////
        
 //async function also ALWAYS returns a promise 
        async function getWeatherAW(woeid) { 
            try{ // fetch is returning a promise
                const result =  await fetch(`https://cors-anywhere.herokuapp.com/https://www.metaweather.com/api/location/${woeid}/`)
            
                // json is returning a promise too
            const data = await result.json() // this is the result json that was fetched turned into json
            const today = data.consolidated_weather[0]
            // console.log(data) //the whole json object turned js object
            console.log(`Temperatures in ${data.title} stay between ${today.min_temp} and ${today.max_temp} celsius`)
                return data // what I return will be the resolved value of the promise that getWeatherAW returns
            } catch(error){
                console.log(error)
            } 
        }

       getWeatherAW(2487956) // Temperatures in San Francisco stay between 8.995000000000001 and 18.494999999999997 celsius
 
       // how to consume a promise from the async function
       // I am storing the return data which the is promise of my for getWeatherAW function london this way 
       let dataLondon;
       getWeatherAW(44418).then(data=> { // london, data can be named anything pop,dot,anything
        dataLondon = data
            console.log(dataLondon, 'test')
           })



    </script>
  </body>
</html>
